package com.toolshare.toolshare.model;

//Using lombok to avoid boilerplate code for getters, setters, constructors, ToString
import lombok.*;
import org.hibernate.validator.constraints.Email;

import javax.persistence.*;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;

import java.util.HashSet;
import java.util.Set;

import static javax.persistence.GenerationType.SEQUENCE;

@ToString
@Getter
@Setter
@EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
@Entity(name = "Participant")
@Table(name = "participant",
        uniqueConstraints = {
                @UniqueConstraint(name = "participant_email_unique",
                        columnNames = "email")
        }
)

public class Participant {

    //Defining id, ensuring it is generated by Spring and immutable
    @Id
    @SequenceGenerator(
            name = "participant_sequence",
            sequenceName = "participant_sequence",
            allocationSize = 1
    )
    @GeneratedValue(
            generator = "participant_sequence",
            strategy = SEQUENCE)
    @Column(name = "id",
            updatable = false)
    private Long id;

    //Defining email, making it non-nullable
    @Email
    @Column(name="email", nullable = false)
    private String email;

    //Defining first name, making it non-nullable
    @NotBlank
    @Column(name="firstname", nullable = false)
    private String firstName;

    //Defining last name, making it non-nullable
    @NotBlank
    @Column(name="lastname", nullable = false)
    private String lastName;

    //Defining postCode, using regex to define valid patten (including the letter codes not used in the Netherlands)
    //Valid pattern does not guarantee the existence of a postcode, more info on this under "constants" in front-end
    @NotBlank
//    @Pattern(regexp="^[1-9][0-9]{3} ?(?!sa|sd|ss|SA|SD|SS)([A-Z]{2}$|[a-z]{2}$)", message="U moet een geldige postcode invoeren")
    @Column(name="postcode", nullable = false)
    private String postcode;

    //Defining photo url, making it non-nullable
    @NotBlank
    @Column(name="photoURL", nullable = false)
    private String photoURL;

    //Defining mobile number, making it non-nullable. Also using a regex expression to ensure ten
    //digits, as is required for Dutch mobile numbers
    @NotBlank
    @Pattern(regexp="^\\d{10}$", message="je mobiele nummer moet tien cijfers hebben")
    @Column(name="mobileNumber", nullable = false)
    private String mobileNumber;

    //Defining one extra constructor - with all variables except the id
    //Note that these fields are needed in the constructor below, lombok takes care of no arg and all arg


    public Participant(String email, String firstName, String lastName, String postcode, String photoURL, String mobileNumber) {
        this.email = email;
        this.firstName = firstName;
        this.lastName = lastName;
        this.postcode = postcode;
        this.photoURL = photoURL;
        this.mobileNumber = mobileNumber;
    }

    //One to one mapping between user and participant. It is not strictly necessary to split these two variables
    //But given the complexity of the Spring Security and JWT, I have done it to separate the security logic from
    //the transaction logic in the code. I find it cleaner this way, and easier to develop.
    @OneToOne(
            cascade = CascadeType.ALL,
            fetch = FetchType.EAGER
    )
    @JoinColumn(
            name = "user_id",
            referencedColumnName = "id",
            foreignKey = @ForeignKey(
                    name = "participant_user_id_fk"
            )
    )
    private User user;

    //One to many-mapping between participant and items (uni-directional)
    //One participant (class name Participant), and (potentially) many items per participant
    @OneToMany(
            orphanRemoval = true,
            cascade = {CascadeType.ALL},
            fetch = FetchType.LAZY
    )
    @JoinColumn(name = "participant_id")
    private Set<ShareItem> items = new HashSet<>();

    //One to many-mapping between participant and "loanActions" (uni-directional)
    //LoanActions are clicks in frontend where the participant gets owner details and use a QR code
    //to send a WhatsApp message to the owner of the item
    //One participant (class name Participant), and many loanActions per participant
    @OneToMany(
            orphanRemoval = true,
            cascade = {CascadeType.ALL},
            fetch = FetchType.LAZY
    )
    @JoinColumn(name = "participant_id")
    private Set<LoanAction> loanActions = new HashSet<>();

}